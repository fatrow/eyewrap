h1. eyewrap

Tracing execution of Clojure code.
Code is completely macroexpanded.
Feel free to tell me problem or code which doesn't work well.

h1. Installation

leiningen
:dev-dependencies [[eyewrap "0.5.8"]]

h1. Usage

<pre class="console">
user> (use 'hozumi.eyewrap)
nil
</pre>

h2. Tracing normal code

 *(cap code)* 

<pre class="console">
user> (cap (+ 1 2))
0 : + (+ 1 2)
0 :=> 3
3
</pre>

<pre class="console">
user> (cap (* 2 (+ (- 3 8) 4)))
0 : + (* 2 (+ (- 3 8) 4))
1 : +   (+ (- 3 8) 4)
2 : +     (- 3 8)
2 :=>     -5
1 :->   (+ -5 4)
1 :=>   -1
0 :-> (* 2 -1)
0 :=> -2
-2
</pre>

You can see the function which throw exception easily.

<pre class="console">
user> (cap (+ 1 3 (- 2 3) (/ 2 0) (* 2 3)))
{:maxid 12, :result {:child {1 {:id 1, :out #<ArithmeticException java.lang.ArithmeticException: Divide by zero>, :child {9 {:id 9, :out #<ArithmeticException java.lang.ArithmeticException: Divide by zero>, :child {12 {:id 12, :out 0, :form 0}, 11 {:id 11, :out 2, :form 2}, 10 {:id 10, :out #<core$_SLASH___4525 clojure.core$_SLASH___4525@3cd6ad74>, :form /}}, :form (/ 2 0)}, 5 {:id 5, :out -1, :child {8 {:id 8, :out 3, :form 3}, 7 {:id 7, :out 2, :form 2}, 6 {:id 6, :out #<core$___4532 clojure.core$___4532@5048ca30>, :form -}}, :form (- 2 3)}, 4 {:id 4, :out 3, :form 3}, 3 {:id 3, :out 1, :form 1}, 2 {:id 2, :out #<core$_PLUS___4509 clojure.core$_PLUS___4509@4079ca2e>, :form +}}, :form (+ 1 3 (- 2 3) (/ 2 0) (* 2 3))}}}, :parent-table {1 nil, 2 1, 3 1, 4 1, 5 1, 6 5, 7 5, 8 5, 9 1, 10 9, 11 9, 12 9}}
0 : + (+ 1 3 (- 2 3) (/ 2 0) (* 2 3))
1 : +   (- 2 3)
1 :=>   -1
0 :-> (+ 1 3 -1 (/ 2 0) (* 2 3))
1 : +   (/ 2 0)
1 :=>   #<ArithmeticException java.lang.ArithmeticException: Divide by zero>
0 :-> (+ 1 3 -1 #<ArithmeticException java.lang.ArithmeticException: Divide by zero> (* 2 3))
0 :=> #<ArithmeticException java.lang.ArithmeticException: Divide by zero>
#<ArithmeticException java.lang.ArithmeticException: Divide by zero>
</pre>

h2. Tracing defn

 *(cap name (defn ... code)* 

<pre class="console">
user> (cap ppp (defn touch [coll target-index]
		 (-> [(coll target-index)]
		     (into (subvec coll 0 target-index))
		     (into (subvec coll (inc target-index))))))
#'user/touch
</pre>

ppp turn to be function.

<pre class="console">
user> ppp
#<user$eval__2153$ppp__2209 user$eval__2153$ppp__2209@4ce1e2b3>
</pre>

still empty

<pre class="console">
user> (ppp)
:const
</pre>

Once defned function has been called, ppp will print trace log.

<pre class="console">
user> (touch [1 2 3 4] 2)
[3 1 2 4]
</pre>

<pre class="console">
user> (ppp)
0 : + (into (into [(coll target-index)] (subvec coll 0 target-index)) (subvec coll (inc target-index)))
1 : +   (into [(coll target-index)] (subvec coll 0 target-index))
2 : +     [(coll target-index)]
3 : +       (coll target-index)
3 :->       ([1 2 3 4] target-index)
3 :->       ([1 2 3 4] 2)
3 :=>       3
2 :->     [3]
2 :=>     [3]
1 :->   (into [3] (subvec coll 0 target-index))
2 : +     (subvec coll 0 target-index)
2 :->     (subvec [1 2 3 4] 0 target-index)
2 :->     (subvec [1 2 3 4] 0 2)
2 :=>     [1 2]
1 :->   (into [3] [1 2])
1 :=>   [3 1 2]
0 :-> (into [3 1 2] (subvec coll (inc target-index)))
1 : +   (subvec coll (inc target-index))
1 :->   (subvec [1 2 3 4] (inc target-index))
2 : +     (inc target-index)
2 :->     (inc 2)
2 :=>     3
1 :->   (subvec [1 2 3 4] 3)
1 :=>   [4]
0 :-> (into [3 1 2] [4])
0 :=> [3 1 2 4]
[3 1 2 4]
user> 
</pre>

<pre class="console">
user> (touch [:a :b :c] 2)
[:c :a :b]
</pre>
<pre class="console">
user> (ppp)
0 : + (into (into [(coll target-index)] (subvec coll 0 target-index)) (subvec coll (inc target-index)))
1 : +   (into [(coll target-index)] (subvec coll 0 target-index))
2 : +     [(coll target-index)]
3 : +       (coll target-index)
3 :->       ([:a :b :c] target-index)
3 :->       ([:a :b :c] 2)
3 :=>       :c
2 :->     [:c]
2 :=>     [:c]
1 :->   (into [:c] (subvec coll 0 target-index))
2 : +     (subvec coll 0 target-index)
2 :->     (subvec [:a :b :c] 0 target-index)
2 :->     (subvec [:a :b :c] 0 2)
2 :=>     [:a :b]
1 :->   (into [:c] [:a :b])
1 :=>   [:c :a :b]
0 :-> (into [:c :a :b] (subvec coll (inc target-index)))
1 : +   (subvec coll (inc target-index))
1 :->   (subvec [:a :b :c] (inc target-index))
2 : +     (inc target-index)
2 :->     (inc 2)
2 :=>     3
1 :->   (subvec [:a :b :c] 3)
1 :=>   []
0 :-> (into [:c :a :b] [])
0 :=> [:c :a :b]
[:c :a :b]
user>
</pre>

You can print previous trace log by calling *(ppp 1)*, because trace log is cached.
*(ppp number)* : print old trace log.
*(ppp :pp)*    : pprint trace log.
*(ppp :c)*     : clear cache.
*(ppp :internal)*    : print internal data.

h1. Not support

h3. *recur, etc...* 




 
h3. License

Eclipse Public License - v 1.0
